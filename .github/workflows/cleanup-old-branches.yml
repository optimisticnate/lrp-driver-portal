name: Cleanup Old Merged Branches

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (show what would be deleted without actually deleting)'
        required: true
        type: boolean
        default: true
      hours_threshold:
        description: 'Delete branches older than this many hours'
        required: true
        type: number
        default: 48

permissions:
  contents: write

jobs:
  cleanup:
    name: Cleanup Old Merged Branches
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0  # Fetch all history for all branches
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch all remote branches
        run: |
          git fetch origin '+refs/heads/*:refs/remotes/origin/*'
          echo "Fetched all remote branches"
          git branch -r | head -20
          echo "..."

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Find and delete old merged branches
        env:
          DRY_RUN: ${{ inputs.dry_run }}
          HOURS_THRESHOLD: ${{ inputs.hours_threshold }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e

          # Configure git to use the token for authentication
          git config --global url."https://x-access-token:${GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"

          echo "ðŸ” Finding merged branches older than ${HOURS_THRESHOLD} hours..."
          echo ""

          # Get the default branch (usually main or master)
          DEFAULT_BRANCH=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5)
          echo "Default branch: ${DEFAULT_BRANCH}"
          echo ""

          # Calculate the cutoff timestamp (current time - threshold hours)
          CUTOFF_TIMESTAMP=$(date -d "${HOURS_THRESHOLD} hours ago" +%s)
          CUTOFF_DATE=$(date -d "${HOURS_THRESHOLD} hours ago" --iso-8601=seconds)
          echo "Cutoff date: ${CUTOFF_DATE}"
          echo ""

          # Get all remote branches except the default branch and other protected branches
          PROTECTED_BRANCHES="${DEFAULT_BRANCH}|HEAD|main|master|develop|staging|production"

          BRANCHES_TO_DELETE=()
          BRANCH_COUNT=0

          # Iterate through all remote branches
          while IFS= read -r branch; do
            # Skip if empty
            [ -z "$branch" ] && continue

            # Get just the branch name without 'origin/'
            BRANCH_NAME="${branch#origin/}"

            # Skip protected branches
            if echo "$BRANCH_NAME" | grep -E "^($PROTECTED_BRANCHES)$" > /dev/null; then
              continue
            fi

            # Check if branch is merged into default branch
            MERGE_BASE=$(git merge-base "$DEFAULT_BRANCH" "origin/$BRANCH_NAME" 2>/dev/null || echo "")
            BRANCH_HEAD=$(git rev-parse "origin/$BRANCH_NAME" 2>/dev/null || echo "")

            if [ -z "$MERGE_BASE" ] || [ -z "$BRANCH_HEAD" ]; then
              echo "âš ï¸  Skipping $BRANCH_NAME (unable to determine merge status)"
              continue
            fi

            # Branch is merged if its HEAD is reachable from default branch
            if git merge-base --is-ancestor "origin/$BRANCH_NAME" "$DEFAULT_BRANCH" 2>/dev/null; then
              # Get the last commit date of the branch
              LAST_COMMIT_TIMESTAMP=$(git log -1 --format=%ct "origin/$BRANCH_NAME" 2>/dev/null || echo "0")
              LAST_COMMIT_DATE=$(git log -1 --format=%ci "origin/$BRANCH_NAME" 2>/dev/null || echo "unknown")

              if [ "$LAST_COMMIT_TIMESTAMP" -lt "$CUTOFF_TIMESTAMP" ]; then
                echo "âœ“ Found: $BRANCH_NAME (last commit: $LAST_COMMIT_DATE)"
                BRANCHES_TO_DELETE+=("$BRANCH_NAME")
                BRANCH_COUNT=$((BRANCH_COUNT + 1))
              fi
            fi
          done < <(git branch -r | grep -v '\->' | sed 's/^[[:space:]]*//')

          echo ""
          echo "=========================================="
          echo "Summary: Found $BRANCH_COUNT branch(es) to delete"
          echo "=========================================="
          echo ""

          if [ $BRANCH_COUNT -eq 0 ]; then
            echo "âœ¨ No branches to delete. All clean!"
            exit 0
          fi

          # Display all branches that will be deleted
          echo "Branches to delete:"
          for branch in "${BRANCHES_TO_DELETE[@]}"; do
            echo "  - $branch"
          done
          echo ""

          if [ "$DRY_RUN" = "true" ]; then
            echo "ðŸ” DRY RUN MODE: No branches were actually deleted."
            echo "   Set 'dry_run' to false to delete these branches."
          else
            echo "ðŸ—‘ï¸  Deleting branches..."
            echo ""

            DELETED_COUNT=0
            FAILED_COUNT=0

            for branch in "${BRANCHES_TO_DELETE[@]}"; do
              if git push origin --delete "$branch" 2>&1; then
                echo "  âœ“ Deleted: $branch"
                DELETED_COUNT=$((DELETED_COUNT + 1))
              else
                echo "  âœ— Failed to delete: $branch"
                FAILED_COUNT=$((FAILED_COUNT + 1))
              fi
            done

            echo ""
            echo "=========================================="
            echo "âœ… Cleanup complete!"
            echo "   Deleted: $DELETED_COUNT branch(es)"
            if [ $FAILED_COUNT -gt 0 ]; then
              echo "   Failed: $FAILED_COUNT branch(es)"
            fi
            echo "=========================================="
          fi

      - name: Cleanup Summary
        if: always()
        run: |
          echo ""
          echo "Cleanup workflow finished."
          echo "Dry run mode: ${{ inputs.dry_run }}"
          echo "Hours threshold: ${{ inputs.hours_threshold }}"
